# javascript  

#### 注释

//                                                      单行注释

/**/                                                  多行注释

## 字面量和变量

字面量：就是一个不可改变的值

变量：用来保存字面量，且变量的值可以任意改变

var                                       声明变量

## 标识符

简单来说就是自己命名的，统称标识符

- 标识符的命名规则
  - 标识符中可以包含字母、_、$、数字
  - 首字符不能是数字
  - 一般采用驼峰命名法
  - 应该见名知意

## 数据类型

- string                                字符串
- number                            数值
- boolean                             布尔
- undefined                        未赋值
- null                                         空
  - 其他数据类型
    - object

### string

- js中的字符串需要使用引号括起来，双引号和单引号都可以，但是不能嵌套

### number

在js中所有的数值都是number类型，包括整数和浮点数还有NaN

### boolean

在js中只有两个值：true / false,主要做逻辑判断

### undefined和null

定义了一个变量未赋值，这个变量就是undefined

null     这个值表示一个空对象

### 转换为string

将一个数据类型强制转换为一个其他的数据类型

- 方法一：tostring（） 方法/函数
  - 调用被转换数据类型的toString方法
  - 该方法不会影响原有的变量，会返回一个转换后的结果
  - null和undefined不能调用，不能带哦用toString
- 方法二：string（）
  - 调用 String() 函数，将需要转换的数据作为参数传递给函数
  -  使用 String() 函数做强制类型转换时：
    - 对于 Number 和 Boolean 实际上就是调用 toString 方法
    - 对于 Null 和 Undefined，就不会调用 toString 方法
    -  将 null 直接转换为 "null"
    - 将 undefined 直接转换为  "undefined"
- 方法三：拼串  +
  - 多个变量中必须有一个字符串

### 转换为Number

- 使用number（）函数

  - 字符串转数字
    - 字符串是纯数字，则可以直接转换为数字
    - 字符串不是一个纯数字，则转换为NaN
    - 字符串是一个空串或者多个空格，则转换为0

  - 布尔转数字
    - true转换为1
    - false转换为0
  - null转数字为0
  - undefined转数字为NaN

- 这种方式专门用于字符串

  - parseInt（）           把一个字符串转换为整数
  - parseFloat（）        把一个字符串转换为浮点数

### 转换为boolean

使用Boolean（）函数

- 数字转布尔
  - 除了0和NaN是false，其他的都是true
- 字符串转布尔
  - 除了空串（''）是false，其余都是ture
- null和undefined都会转换为false
- 对象也会转换为true

## 运算符

#### 算术运算符

% +  *  -  /

#### 一元运算符

正号：+    不会对数字产生影响

负号：-     可以对数字进行取反

#### 自增和自减

++  --  

前置：先运算在赋值

后置：先赋值后运算

#### 逻辑运算符

- ！非
  -  对一个值进行取反
- && 与
  - 两边值都是true才能返回true
- ||或 
  - 只有一个值为true，则直接返回true
  - 只有两个值为false，才会返回false

#### 赋值运算符

+=   -=   *=   /=   %=

#### 关系运算符

返回一个布尔值

- 通过关系运算符可以比较两个值的大小关系，如关系成立则返回true，反之
- 对于非数值比较，会转换为数字进行比较

#### 赋值运算符

- ==    
  - 当使用==来比较两个值的时候，若类型不一样，则自动进行类型转换，转换为相同类型再比较
- ！=
  - 用于判断两个值是否不相等，如果不相等就返回true，否则就返回false，不相等用于比较运算，也会进行类型转换
- ===       全等
  - 用于判断连两个值是否相等，它和相等类型。不同的是全等不会做类型转换，若两个值的类型不一样，则直接返回false
- ！==  不全等
  - 用于判断两个值是否不全等，他和不相等类型类似，不同的是不全等不会做类型转换，若两个值类型不一样，则直接返回true

#### 三元运算符

条件运算符/三元运算符/三目运算符

​	X > 0 ? X : -X

```html
 console.log(age >= 18 ? '成年' : '未成年');
```

### 代码块

- 语句是程序中的基本的一个执行单位，是按照从上往下的顺序依次执行

- 在js中使用{}来为语句分组
- 同一个{}里面的语句，称为一句语句，要么一起执行，要么不执行，这样一组语句我们称为代码块

### 流程控制语句

- 通过流程控制语句可以控制程序的执行流程，使程序可以根据一点的条件来选择执行
- 语句的分类
  - 条件判断语句
  - 条件分支语句
  - 循环语句

#### 条件控制语句

使用条件判断语句可以在执行某个语句之前做出判断，如果条件成立才会执行语句，不成立则不执行

   if（条件表达式）{

​		语句....

}

#### 条件分支语句

和条件控制语句功能相等

​	switch（条件表达式）{

​	case 表达式：

​	语句......

​	break

​	dafault（不是必须的）

​	语句

​	break

}

#### 循环语句

通过循环语句可以反复执行一段代码多次

​	while（条件表达式）{

​		语句.....

}

​	do{

​	语句......

}while（条件表达式）

### for循环

for循环专门提供了位置来存放3个表达式：

- 初始化表达式
- 条件表达式
- 更新表达式

#### 跳出循环

break 跳出最近的循环，也就是只能跳出一次

continue  终止当此循环，后面代码不执行，直接到更新表达式执行下一次

## 对象

对象属于一种复合数据类型，在对象中我们可以保存多个不同数据类型的属性

- js对象的分类

  - 内建对象
    - 由ECMAscript标准中定义的对象，在任何ES的实现中（浏览器的js引擎）
  - 宿主对象
    - 由js运行环境提供的对象
      - Bom（浏览器对象）
      - Dom（文档对象）

  - 自定义对象
    - 由开发人员自己创建的对象
- 创建对象
  - new 构造函数
  - 使用字面量的方式

#### 属性名和属性值

- 属性名建议采用表示符规则去命名，一般去用 . 方式去操作

-  如果要使用特殊的属性名，不能采用 . 方式操作，读取属性值也需要采用这种方式

对象中的内存中的存储

- 对象实际上是存储在堆内存中
- 在栈内存中存储的是对象在堆内存的首地址

检查对象是否是否含有某一个属性

- 使用in运算符

遍历对象的所有属性

- for.....in

- 语法：for (var attr in 对象) {}
  - attr 变量用于接收对象中的每一个属性名
  - 要获取属性值：对象[attr]

## 函数

函数function

- 函数也是一个对象
- 函数中可以封装一下功能代码，在需要时我们可以执行这些功能代码
- 使用typeof检查一个函数时，还function



#### 创造函数方式

- 实际开发不建议使用

  - new Function（） 构造函数方式

- 使用函数声明function关键自来创建一个函数

  - 语法：

    - function 函数名（形参，形参，形参）{

      ​	语句......

      }

- 使用函数表达式（字面量）方式类创建函数

  - 语法：

    - var 函数名 = function（形参，形参，形参）{

      语句........

    }

#### 函数的参数传递

值传递：实参是基本数据类型，传递的是值

引用传递：实参是引用数据类型，传递的是对象的引用地址

#### return返回值

- return后面的值可以作为一个函数的执行结果返回
- return后面的语句不会在执行
- return语句没有任何值，则相当于返回一个undefined
- return后面可以根任意类型的值

#### 对象的浅拷贝

- 实际上就是基本数据类型的拷贝，拷贝一层
- 浅拷贝没有属性的值是对象类型的问题，对象拷贝的是引用地址

### 函数的分类

- 普通函数
- 匿名函数
- 立即执行函数
- 构造函数
- 回调函数
- 钩子函数

#### 立即执行函数

函数定义完成，立即被调用，这种函数叫立即执行函数，立即执行函数往往只能执行一次

- 语法：（定义函数）（形参）

## 作用域

- 局部作业域
  - 作用域值一个变量的作用的范围
  - 在js中一共有两种作用域
- 全局作用域
  - 直接在script标签编写的代码，都在全局作用域中
  - 全局作用域在页面打开时创建，页面关闭时销毁
  - 在全局作用域中有一个全局对象window
    - window代表的是一个浏览器窗口，浏览器创建，我们可以使用
- 在全局作用域：
  - 创建的变量都会作为window对象的属性保存
  - 创建的函数都会作为window对象的方法保存
  - 在全局作用域中的变量都是全局变量，在页面中任意位置都可以访问

## 函数声明

- 变量的声明提前
  - 使用var关键字声明的变量，会在所有的代码之前被声明（但不会赋值），没有使用var关键字声明变量，则变量不会被声明提前
- 函数的声明提前
  - 使用函数声明的形式创建的函数 function fun （）{}，它会在所有的代码执行之前就被创建，所有我们可以在函数声明前来调用函数
  - 使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用

## debug  断点测试

由浏览器提供的开发者工具（f12）

1. 打断点
2. 监控变量，把需要监控的变量加入到监控表达式中，可以动态的查看到变量的一个变换
3. 使用单不进入（F10）来让代码一行一行来执行

## this

js解析器在调用函数时，每次都会向函数内部传递进一个隐含参数，这个隐含参数就是this，this指向的是一个对象，这个对象我们称为函数执行的上下文对象

- 以函数的形式调用时，this永远都是window
- 以方法形式调用时，this就是调用方法的那个对象
- 当以构造函数的形式调用，this就是新建的那个对象，实际上就是new出来的那个对象
- 使用 call 和 apply 调用，this 是指定的那个对象

## 对象工厂方法

解决对象创建问题，把对象创建的实现细节隐藏，有工厂方法去实现，我们只需要调用工厂方法就可以创建好对象

## 设计模式

用于解决某一类问题的一种思想，实际上就是一堆优秀代码的集合

## 全局污染

减少全局污染方式

​	尽量不要在全局环境定义变量

- 在全局定义一个公共的命名空间，所有全局的资源都定义在公共的命名空间内
- 闭包

## 原型  prototype

- 我们创建的每一个函数，解析器都会向内部添加一个属性prototype，其属性对于这一个对象，这个对象就是我们所谓的原型对象
- 当我们访问对象的一个属性或方法时，它会先在对象自身中查找，如果有则直接使用，没有则去原型对象找，找到则直接使用
- 原型对象也是对象，所有它也会有原型
  - 自身找如果有，则直接使用
  - 如果没有，则去原型中寻找，如果原型中有则使用
  - 如果原型中没有，则去原型的原型中寻找，直接找到object对象的原型
  - object对象的原型没有原型，如果在object原型中依然没有找到，属性返回undefined

## 闭包

指有权限访问另外一个函数作用域中的变量的函数，创建闭包的常见方法，就是在一个函数内部创建一个函数

使用场景：

- 减少全局污染
- 延长外部函数的生命周期

缺点：

由于外部函数没有被及时销毁，若太多闭包，会造成内存溢出

## 垃圾回收

- 程序运行过程中也会产生垃圾这些垃圾积攒过多以后，会导致程序运行的速度变慢所有我们需要一个垃圾回收机制，来处理程序运行过程中产生的垃圾

-  当一个对象没有任何的变量或属性对它进行引用，此时我们永远无法操作该对象此时这种对象就是一个垃圾对象，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须清理

- 在JS中拥有自动垃圾回收机制，会自动将这些垃圾对象从内存中销毁我们不需要也无法干预垃圾回收的操作

- 我们需要做的是将不再使用的对象设置 null 即可

## 数组  Array

- 数组也是一个对象
- 和普通对象功能类似，也是用来存储一些个值
- 不同的时普通对象是使用字符串作为属性名，而数组是使用数字作为索引操作元素
- 索引（下标）：从0开始就是索引
- 数组的存储性能比普通对象要好，在开发中经常使用数组来存储数据

#### 数组的创建方法

- 字面量        语法：[ ]
- 使用构造函数创建数组               new  Array（）

#### 数组的方法

- push ( ) 在末尾添加一个或者多个元素
- pop (  )  删除数组最后一个元素
- unshift (  )  开头添加一个元素
- shift (  )  该方法可以删除数组的第一个元素
- sort（）   排序数组： 和回调函数配合
- reverse     反转数组
- split    字符串转数组
- join       将数组转换为字符串
- concet          合并多个数组，返回新数组，不影响原数组   
- splice（）（字符串截取）
  - 1个参数：删除
  - 2个参数：删除
  - 3个及3个以上参数：
  - 第二个参数是0 新增
  - 第二个参数不是0 修改

#### 数组的遍历

-  forEach() 遍历数组

- value 对应 数组中的每个元素的值

- index 对应 数组中的每个元素的索引

 arr.forEach(function(value, index, array) {

​      console.log(index + ":" + value);

​    })

## call和apply



-  call() 和 apply():  执行函数，指定 this
  - 这两个方法都是函数对象的方法，需要通过函数对象来调用

  - 当对函数调用 call 和 apply 方法都会调用函数执行

  - 在调用 call 和 apply 时，可以将一个对象指定为第一个参数

     此时这个对象将会成为函数执行时的 this

  - call() 方法可以将实参在对象之后依次传递

  - apply() 方法需要将实参封装在一个数组中，然后统一传递

- ​     call 和 apply 这两个方法在功能是一样的，只是在传递参数的形式上有区别

   call 是一个一个的依次传递参数

   apply 是将参数封装在一个数组中，统一传递

## argument（第二个隐含属性）

在调用函数时，浏览器每次都会传递进两个隐含的参数

1. this，函数的上下文对象

2. arguments，封装实参的对象

- arguments 是一个类数组对象，它可以通过索引来操作数据，也可以获取长度

- 在调用函数时，我们传递的实参都会封装在 arguments 类数组对象中

- arguments.length 可以用来获取实参的个数

- 我们即使不定义形参，也可以通过 arguments 来使用实参

   arguments[0] 第一个实参

   arguments[1] 第二个实参

-  它里面有一个属性叫 callee

    这个属性对应着一个函数对象，就是当前正在指向的函数对象

## Date   时间对象

- 如果直接使用构造函数来创建一个Date对象，会封装当前时间代码执行的时间
- 创建一个指定的时间对象，需要在构造函数中传递一个表示时间的字符串作为参数
  - 格式：月份/日/年  时：分：秒

代码：

- getDate（） 获取当前日期对象是几日
- getDay （） 回去当前对象是周几  （0~6）
- getMonth (  )获取当前日期对象的月份（0~11）

- getFullYear(  )获取当前日期对应的年份
- getTime(   )兑取当前日期对象的时间戳（格林威治标准时间的1970年1月1日 0时0分0秒）

## Math  内置对象

Math和其他对象不同，它不是一个构造函数，它属于工具类，不会创建对象，它里面封装了数字运算相关的属性和方法

-  abs(   ) 可以计算一个数的绝对值

- Math.ceil (  )     可以对一个数向上取整，小数位只要有值就进 1

- Math.floor(   )      可以对一个数向下取整，小数位部分直接舍掉

- Math.round(   )      可以对一个数进行四舍五入取整
- Math.random(  )  可以用来生成一个 0 - 1 之间的随机数
- max(   ) 可以获取多个数中的最大值
- min(    ) 可以获取多个数中的最小值
- Math.pow(x,y)           返回 x 的 y 次幂
- Math.sqrt (  )           用于对一个数进行开方运算

## 包装类

String  (  )        可以将基本数据类型字符串转换为 String 对象

Number(  )        可以将基本数据类型数值转换为 Number 对象

Boolean(   )       可以将基本数据类型布尔值转换为 Boolean 对象

## 字符串

- 字符串是一个不可变的字符序列
- 创建一个字符串

length   获取字符串的长度

charAt (  )         可以返回字符串中指定位置的字符

charCodeAt(    )  获取指定字符串的字符编码 (Unicode 编码)

String.fromCharCode()   可以根据字符编码去获取字符

concat             可以用来连接多个字符串（和+一样）

indexOf (  )     该方法可以检索给定字符串是否有指定的内容

lastIndexOf(  )   同上， 不同的是indexOf是从前往后查找

slice （）    截取

trim （） 去左右空格

substring  (  )   截取    不同是传入两个参数（开始位置所有）（结束位置索引）

substr  (start, length)      截取字符串长度 （开始索引）（截取长度）

split (  )	   

- 将一个字符串拆分成一个数组    需要一个字符串作为参数，会根据该字符串去拆分数组

- 可以用空串和正则表达式去拆分
- toLowerCase(  )    将一个字符串转换为小写
- toUpperCase(  )    将一个字符串转换为大写
- replace (  )          替换字符串中指定的内容

## 正则表达式

操作字符串

#### 创建正则表达式

- var 变量 = new RegExp("正则表达式", "匹配模式")
  -  在 正则对象的 构造函数中可以传递一个匹配模式作为第二个参数
    - i 忽略大小写
    - g 全局匹配模式
- 使用 字面量 方式来创建一个正则对象
  - var reg = / \\ . /i
  - var reg = /正则表达式/匹配模式(i/g)

#### 正则表达式的方法

- test(  )     使用这个方法可以用来检查一个字符串是否符合正则表达式的规则

- split (  )        将一个字符串拆分为一个数组

- search (  )	搜索字符串中是否含有指定的内容  (返回下标)

- match(  )	从一个字符串中将符合条件的内容提取出来

- replace(被替换的内容, 新的内容)                      
  - 以将字符串中指定的内容替换为新的内容

#### 正则的转义符

.  在正则中表示任意字符

- 在正则表达式中使用 \ 作为转义符
  -  \\. 表示 .
  - \\\ 表示 \

#### 正则表达式的规则

<显示问题！！！！>

\w                    任意字母、数字、_ [A-z0-9_]

\W			除了字母、数字、_ [^A-z0-9_]

\d			任意的数字 [0-9]

\D			除了数字 [^0-9]

\s			空格

\S			除了空格

\b			单词边界

\B			除了单词边界

.                       任意字符

#### 正则的量词

- 通过量词可以设置一个内容出现的次数

- 量词只能对它前面的一个内容起作用

- {n} 正好出现 n 次

- {m, n} 出现 m ~ n 次

- {m,} m 次以上

+ +至少一次，相当于 {1,}

* *0个或多个，相当于 {0,}

- ? 0个或者1个，相当于 {0,1}

## DOM

浏览器已经为我们提供了 文档阶段 对象 document，这个对象是 window 对象的一个属性，
可以在页面中直接使用，文档节点 代表的是整个网页

#### 事件

事件，就是用户和浏览器之间的交互行为
   比如：点击按钮、鼠标移动、关闭窗口...

 我们可以为按钮的对应事件绑定处理函数的形式来响应事件
 这样当事件被触发时，其对应的函数将会被调用执行

 我们可以在事件对应的属性中设置一些js代码
   这样当事件触发时，这些代码将会被执行

#### 事件总和

window.onresize 窗口大小改变时触发的事件

.onchange            值发生变化时触发的事件

onscroll 窗口滚动的事件

window.onresize 窗口大小改变时触发的事件

mousedown 鼠标按下事件  
mousemove 鼠标移动事件  
mouseup 鼠标抬起事件

- onclick
  - 鼠标点击事件
- onmouseover
  - 鼠标移入事件
- onmouseout
  - 鼠标移出事件
- onchange   
  - 发生改变时触发的函数
- onscroll
  - 滚轮滚动的事件

- onfocus
  - 元素获得焦点时触发，焦点通常是指 鼠标光标
- onblur
  - 元素失去焦点时触发
- onchange
  - 内容改变触发
- onsubmit
  - 提交表单，这个事件只能作用在 form 表单上

- onresize
  - 大小改变时触发的事件
- oncintextmenu
  - 右键菜单的事件

#### 文档执行

浏览器在加载一个页面时，是按照自上向下的顺序加载，
读取到一行就运行一行，如果将 script 标签写到 head 标签中，
在代码执行时，页面还没有加载，DOM 的对象也还没有加载完成，
这样会导致无法获取到 DOM 对象

onload 事件会在整个页面加载完成之后才会触发
为 window 绑定一个 onload 事件
该事件对应的响应函数将会在页面加载完成之后执行
这样可以确保我们的代码执行时，所有的DOM对象已经加载完毕

onload 的页面加载完成的定义：

1. DOM树绘制完成
2. 页面中所有的内容显示完成（包含图片、音视频等...

#### 文档查询

Node 节点
   - 文档节点
   - 元素节点
   - 属性节点
   - 文本节点

  nodeName
   - 文档节点 #document
   - 元素节点 标签名
   - 属性节点 属性名
   - 文本节点 #text
       nodeType
   - 1 元素节点
   - 2 属性节点
   - 3 文本节点
   - 9 文档节点
       nodeValue
   - 文档节点、元素节点 nodeValue 的值为 null
   - 属性节点的 nodeValue 的值就是 属性的值
   - 文本节点的 nodeValue 的值就是文本内容

  getElementById(id值)
   - 根据元素的id属性值来获取元素节点对象，返回的是一个元素对象
       getElementsByTagName(标签名)
   - 根据标签名来获取一组元素节点对象，返回的是一个元素节点对象的集合（类数组）
       getElementsByName(name属性值)
   - 根据元素的name属性值来获取一组元素节点对象，返回的是一个元素节点对象的集合（类数组）
       getElementsByClassName(class属性值) IE9 以上
   - 根据元素的class属性值来获取一组元素节点对象，返回的是一个元素节点对象的集合（类数组）
   - 获取boby对象
          - document.getElementsByTagName("body")[0]
   - 需要也给选择器的字符串作为参数，可以根据一个css选择器来查询一个元素节点对象，ie8不支持查询，但可以用querySelector代替，该方法返回的是一个元素节点
          - querySelector
   - 该方法和上面类型，不同的是他将符合元素封装到一个数组中返回，返回一个数组
          - querySelectAll

  

​	firstChild

   - 获取第一个子节点
       lastChild
   - 获取最后一个子节点
       childNodes
   - 获取子节点
       parentNode
   - 获取父节点
       previousSibling
   - 获取前一个兄弟节点
       nextSibling
   - 获取后一个兄弟节点
       注意：以上属性，会把换行符算为一个 文本 节点

  innerText
   - 用于获取或设置节点对象的文本值
       innerHTML

   - 用于获取或设置节点对象的内部HTML结构(代码)



        querySelector(CSS选择器)
    
       - 需要也给选择器的字符串作为参数，可以根据一个css选择器来查询一个元素节点对象
       - 虽然IE8不支持getElementsByClassName方法，但是可以使用 querySelector 代替
       - 该方法总会返回唯一的一个元素节点对象，如果满足条件的有多个，那么它只能返回第一个

querySelectAll()

- 该方法和 querySelector 用法类似，不同的是他将符合条件的元素封装到一个数组中返回
- 即使符合条件的元素只有一个，它也返回数组

#### DOM增删改

 DOM 节点的增删改操作

  添加：
  appendChild(node)

- 追加一个节点到末尾
  insertBefore(newNode, refNode)

- 将一个 newNode 节点添加到 refNode 这个节点之前

  修改：
  replaceChild(newNode, oldNode)

- 使用 newNode 替换 oldNode

  删除：
  removeChild(node)

- 删除一个节点

  注意：上面的四个方法，都是父节点来调用

  innerHTML

- 将 html 代码添加到指定的节点下，浏览器会解析添加的 HTML 代码

- .insertBefore 在某个元素前添加节点

- offsetParent 查找右定位的祖先节点 

  - 找到元素的定位，如果没有，则为body

- offsetLeft 到右定位的祖先节点的左距离

- offsetWidth dom节点的宽度 = width+border*2 +padding*2

- clientWidth dom节点的宽度 = width+ padding*2

- document.documentElement.clientHeight 文档的高度

- clientLeft 到屏幕的border的距离

- window.innerWidth 窗口的可视区宽度

- window.innerHeight 窗口的可视区高度 

- scrollHeight dom节点滚动条可滚动的部分

- document.body.offsetHeight 整个文档的高度

- .window.open 打开新窗口

- .window.close 关闭当前窗口（默认）

- .window.location.hash  hash值主要可以保存路由信息

- .search 如百度一样在url后面显示的 搜索信息

- .window.navigator.userAgent 可以判断浏览器类型及pc移动端等	

- window.location.reload() 页面重新加载

- clientX clientY 点击位置距离当前的浏览器body可视区的x,y坐标

- pageX  pageY    pageX = clientX + 横向滚动的距离;

  pageY = clientY + 纵向滚动的距离

- screenX  screenY     到当前的电脑屏幕的x,y轴坐标

- offsetX offsetY   到最近的有定位的父级节点的x,y轴坐标- - --

- ev.cancelBubble = true; 取消事件冒泡

- ev.stopPropagation();    取消事件冒泡//  ie8及以下不支持

- attachEvent 绑定事件 ie8 及以下浏览器

- addEventListener  绑定事件 其他浏览器

- detachEvent 取消绑定事件 ie8 及以下浏览器

- removeEventListener 取消绑定事件 其他浏览器

- return false;  阻止默认事件

- ev.preventDefault(); 阻止默认事件

- cloneNode 克隆节点

- querySelector 可以通过标签名、id、classname获取一个元素

- querySelectorAll  可以通过标签名、id、classname获取一组元素

- search 查找 

#### 获取元素的样式

获取元素当前显示的样式
语法：元素.currentStyle.样式名
它可以用来读取元素当前正在显示的样式
如果当前元素没有设置样式，则获取它的默认样式

currentStyle 只有 IE 浏览器支持，其它浏览器都不支持

console.log(box1.currentStyle.width);

在其它的浏览器中可以使用
getComputedStyle() 这个方法来获取元素当前正在显示的样式
这个方法是 window 的方法，可以直接使用

需要两个参数：
第一个参数：获取样式的元素
第二个参数：可以传递一个伪元素，一般都传入 null

该方法返回一个对象，对象中封装了当前元素对应的样式
可以通过该 对象.样式名 来读取样式
如果获取的样式没有设置，则会获取真实的值，而不是默认值
比如没有设置 width，它不会返回 auto，而是一个长度

只能获取显示的样式，不能修改样式

#### 其他样式属性获取

- clienWidth
- clientHeight
  - 这两个属性可以获取元素的可见宽度和高度
  - 这些属性都是不带px的，返回的是一个数字，可以直接进行计算
  - 用于获取元素的高度和宽度，包括外边距和内边距
  - 这些属性都是只读的，不能修改

- offsetWidth
- offsetHeight
  - 获取整个宽度和高度，包括内容区，内边距和边框
- offsetParent
  - 用于获取当前元素的定位父元素
  - 会获取到当前元素最近的开启了定位的祖先元素，如果所有的祖先元素都没有开启定位，则返回boby
- offsetLeft
  - 获取当前元素相对于其定位父元素的水平偏移量
- offsetTop
  - 获取当前元素相对于其定位父元素的垂直偏移量
-  scrollWidth
   scrollHeight
  *  可以获取元素整个滚动区域的宽度和高度

* scrollLeft
  - 获取水平滚动条滚动的距离
* scrollTop
  - 获取垂直滚动条滚动的距离

#### 事件对象

  event 事件对象
   - 当事件的响应函数被触发，浏览器每次都会将一个事件对象传递进响应函数
   - 事件对象封装了当前事件相关的一切信息
     比如：鼠标坐标、键盘是按那个键、鼠标滚轮滚动方向...

#### 事件的冒泡

事件冒泡 (Bubble)

- 事件冒泡指的是事件的向上传导，当后代元素上的事件被触发，其祖先元素的相同事件也会被触发
- 如果不想让祖先上的元素触发，则可以在当前元素上取消冒泡

#### 事件的委派

事件委派：

- 值将事件统一绑定到元素的共同祖先元素上，这样当后代元素上的事件触发时，会一直冒泡到祖先元素 从而通过祖先元素的响应函数来处理事件
- 事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提供程序的性能

#### 事件的绑定

使用 对象.事件 = 响应函数(回调函数)

- 它只能同时为一个元素的一个事件绑定一个函数不能绑定多个，如果绑定了多个，则后边的会覆盖前面的

#### 事件的传播

事件的传播

- 关于事件的传播网景公司和微软公司有不同的理解
- 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件， 然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。
- 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件， 然后在向内传播给后代元素
- W3C综合了两个公司的方案，将事件传播分成了三个阶段 
- 1.捕获阶段
  - 在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件
-  2.目标阶段
  - 事件捕获到目标元素，捕获结束开始在目标元素上触发事件
-  3.冒泡阶段
  - 事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件
- 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true 一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false
- IE8及以下的浏览器中没有捕获阶段

#### 滚轮事件

  onmousewheel 鼠标滚轮滚动事件，会在滚动时触发
   但是 firefox 不支持该属性, 不会报错

  在firefox 浏览器中需要使用 DOMMouseScroll 来绑定该事件
   这个事件只能通过 addEventListener () 方法来绑定

- firefox
     - 向上滚动 -3
     - 向下滚动 3

   - 其它浏览器
         - 向上滚动 120
         - 向下滚动 -120

#### 键盘事件

 onkeydown
   - 键盘按钮被按下
   - 对于 onkeydown 事件，如果一直按着不松手，这个事件一直触发
   - 当 onkeydown 连续触发时，第一次和第二次之间间隔时间稍长，后面就基本上没有延迟
     这种设计是为了误操作发生

  onkeyup
   - 按键被松开

  键盘事件一般都会绑定给一些可以获取到焦点的对象 或者是 document

  可以通过keyCode来获取按键的编码
   通过keyCode编码可以判断哪个按键被按下
  除了 keyCode，事件对象中还提供了几个属性
   altKey
   ctrlKey
   shiftKey

     - 这三个用来判断 alt ctrl shift 是否被按下
       如果按下则返回 true，否则返回 false

## BOM

- 浏览器对象模型
- BOM 可以使我们通过 js 来操作浏览器
- 在 BOM 中为为我们提供了一组对象，用来完成对浏览器的操作
- BOM 对象
  - window
    - 代表的整个浏览器的窗口，同时window也是网页中的全局对象
  - Navigator
    - 代表当前浏览器的信息，通过该对象可以来识别不同的浏览器
  - Location
    - 代表当前浏览器的地址信息，通过 location 可以获取地址栏信息，或者操作浏览器跳转页面
  - History
    - 代表浏览器的历史纪录，可以通过 该对象 来操作浏览器的历史纪录 由于可能涉及到隐私，该对象不能获取到具体的历史记录，只能操作浏览器向前或者向后翻页
  - Screen
    - 代表用户的屏幕信息，通过该对象可以获取用户显示器的相关信息

这些 BOM 对象在浏览器中都是作为 window 对象的属性保存的。 可以通过 window 对象来使用，也可以直接使用

- Navigator
  ​    - 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
  - 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了
- 一般我们只会使用userAgent来判断浏览器的信息，
     userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，
     - 不同的浏览器会有不同的userAgent

#### History  前进和后退

- History
  - 对象可以用来操作浏览器向前或向后
- back
  - 回退到上一页，作用和浏览器的回退按钮一样
- forward
  - 可以跳转到下一个页面，作用和浏览器的前进按钮一样
- go(变量)[取值为-2~2]
  - 可以用来跳转指定的页面
  - 它需要一个整数作为参数 1：表示向前跳转一个界面，相当于forward() 2：表示向前跳转两个界面 -1 ：表示向后跳转一个界面，相当于back() -2 ：表示向后跳转两个界面

#### Location 刷新

- Location
  - 该对象封装了浏览器的地址栏信息，主要用来刷新页面
- assign
  - 用来跳转到其他页面，作用和直接修改href属性一样
- reload
  - 用于重新加载当前页面，作用和刷新按钮一样F5键
  - 如果在方法中传递一个true作为参数，则会强行情况缓存刷新页面
- replace
  - 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面 不会生成历史记录，不能使用回退按钮回退

#### 定时调用

setInterval(callback, time)

- 定时器调用
- 可以将一个函数，每隔一段时间调用一次
- 参数：
  1. 回调函数，该函数每隔一段时间会被调用一次
  2. 每次调用间隔的时间，单位是毫秒
- 返回值
  - 返回一个number类型的数据 这个数字用来作为定时器的一个标识

clearInterval()

- 可以用来关闭一个定时器
- 方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器

#### 延时调用

延时调用  setTimeout

- 延时调用一个函数不马上执行，而是隔一段时间以后再执行，而且只会执行一次

延时调用 和 定时调用的区别？

- 定时调用会执行多次，而延时调用只执行一次 延时调用和定时调用实际上是可以相互替代的，在开发中可以根据需要去选择

##  JSON

JSON (JavaScript Object Notation) js对象表示法 是一种轻量级数据传输格式

- JS中的对象只有js自己认识，其它语言不认识
- JSON就是一个特殊格式的字符串，这个字符串可以被任意（大部分）语言所识别 并且可以转换为其它语言的对象，JSON在开发中主要用来数据的交互
- JSON JSON 和 JS 对象的格式一样，只不过JSON字符串中的属性名必须加 双引号 其它的和js语法一致
- JSON分类

1. 对象 {}
2. 数组 []

- JSON 中允许的值

1. 字符串
2. 数值
3. 布尔值
4. null
5. 对象
6. 数组

轻量级 json，不依赖第三方 API (Application Program Interface)，可以在本地语言直接解析 在js中可以直接使用，不需要依赖第三方 重量级 xml，必须依赖第三方 API 来操作 比如：dom4j、jdom

JSON这个对象在IE7及以下浏览器不支持，所以在这些浏览器中调用会报错

- 解决方案：

  1. json2.js (完美)
  2. eval() （缺点大于优点）

  eval()

  - 这个函数可以用来执行一段字符串形式的js代码，并将执行结果返回
  - 如果使用 eval() 执行的字符串中包含有 {}, 它将 {} 当成代码块执行， 若不希望将其当次代码块执行，则需要在字符串的前后各加一个 ()

- eval() 

  - 这个函数的功能特别强大，可以直接执行一个字符串中的js代码 但是在开发中尽量少用，首先它的执行性能比较差，最主要是具有安全隐患





## 异步线程

http://www.ruanyifeng.com/blog/2014/10/event-loop.html

